% Template for a Computer Science Tripos Part II project dissertation
\documentclass[12pt,a4paper,twoside,openright]{report}
\usepackage[pdfborder={0 0 0}]{hyperref}    % turns references into hyperlinks
\usepackage[margin=25mm]{geometry}  % adjusts page layout
\usepackage{graphicx}  % allows inclusion of PDF, PNG and JPG images
\usepackage{verbatim}
\usepackage{docmute}   % only needed to allow inclusion of proposal.tex


\usepackage{listings}       % Source code listings
\usepackage{courier}        % courier font
\lstset{
  basicstyle=\ttfamily
, commentstyle=\color{Green}
, keywordstyle=\bfseries\color{RoyalBlue}
, showspaces=false
, showstringspaces=false
, breaklines=true
, breakatwhitespace=true
, framextopmargin=50pt
, columns=fullflexible,keepspaces
, escapeinside={(*}{*)}
%, frame=bottomline
      }



\raggedbottom                           % try to avoid widows and orphans
\sloppy
\clubpenalty1000%
\widowpenalty1000%

\renewcommand{\baselinestretch}{1.1}    % adjust line spacing to make
                                        % more readable

\begin{document}

\bibliographystyle{plain}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title


\pagestyle{empty}

\rightline{\LARGE \textbf{Cheng Sun}}

\vspace*{60mm}
\begin{center}
\Huge
\textbf{An observable OCaml via C and \lstinline!liballocs!} \\[5mm]
Computer Science Tripos -- Part II \\[5mm]
Churchill College \\[5mm]
\today  % today's date
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Proforma, table of contents and list of figures

\pagestyle{plain}

\chapter*{Proforma}

{\large
\begin{tabular}{ll}
Name:               & \bf Cheng Sun                       \\
College:            & \bf Churchill College                     \\
Project Title:      & \bf An observable OCaml via C and \lstinline!liballocs! \\
Examination:        & \bf Computer Science Tripos -- Part II, July 2017  \\
Word Count:         & \bf 1587\footnotemark[1] \\
Project Originator: & Stephen Kell                    \\
Supervisor:         & Stephen Kell                    \\
\end{tabular}
}
\footnotetext[1]{This word count was computed
by \texttt{detex diss.tex | tr -cd '0-9A-Za-z $\tt\backslash$n' | wc -w}
}
\stepcounter{footnote}


\section*{Original Aims of the Project}

%TODO
%To write a demonstration dissertation\footnote{A normal footnote without the
%complication of being in a table.} using \LaTeX\ to save
%student's time when writing their own dissertations. The dissertation
%should illustrate how to use the more common \LaTeX\ constructs. It
%should include pictures and diagrams to show how these can be
%incorporated into the dissertation.  It should contain the entire
%\LaTeX\ source of the dissertation and the makefile.  It should
%explain how to construct an MSDOS disk of the dissertation in
%Postscript format that can be used by the book shop for printing, and,
%finally, it should have the prescribed layout and format of a diploma
%dissertation.


\section*{Work Completed}

%TODO
%All that has been completed appears in this dissertation.

\section*{Special Difficulties}

%TODO
%Learning how to incorporate encapulated postscript into a \LaTeX\
%document on both Ubuntu Linux and OS X.
 
\newpage
\section*{Declaration}

I, Cheng Sun of Churchill College, being a candidate for Part II of the Computer
Science Tripos, hereby declare
that this dissertation and the work described in it are my own work,
unaided except as may be specified below, and that the dissertation
does not contain material that has already been used to any substantial
extent for a comparable purpose.

\bigskip
\leftline{Signed [signature]}

\medskip
\leftline{Date [date]}

\tableofcontents

\listoffigures

\newpage
\section*{Acknowledgements}

%TODO
%This document owes much to an earlier version written by Simon Moore
%\cite{Moore95}.  His help, encouragement and advice was greatly 
%appreciated.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% now for the chapters

\pagestyle{headings}

\chapter{Introduction}

%TODO


\chapter{Preparation}

%TODO


\chapter{Implementation}

\section{Summary and structure of code}

\begin{enumerate}
  \item the driver
  \item the compilation module
    \begin{enumerate}
      \item AST
      \item translate
      \item fixup
      \item emitcode
    \end{enumerate}
  \item the runtime
    \begin{enumerate}
      \item OCaml standard library
      \item C runtime library
    \end{enumerate}
\end{enumerate}

\section{Closures}

C allows function pointers to be stored and passed around in variables. These variables point to the start of the function's machine code in memory. Function calls are performed on function pointers by simply jumping to their address (using the \lstinline{call} instruction).

The C language has no notion of closures, which OCaml requires to provide support for lexical scoping of variables in first-class functions. Closures are conceptually a tuple of the function pointer and the ``environment'' of the closure, which contains information about the free variables of the closure.

We would like our closure pointers to be behaviourally equivalent to a function pointer from the C caller's perspective, i.e. calling
\lstinline{closure(1, 2, 3)}
(with the standard C calling convention) transparently translates to a call to
\lstinline{closure_impl(1, 2, 3, env)}. This precludes techniques such as ``fat pointers'', where closures are stored as a tuple of two pointers. The disadvantage of such techniques includes the fact that each indirect function call must first check whether the variable is fat or not -- a significant runtime penalty.

The technique that we use involves the creation of machine code stubs at runtime was pioneered by Breuel (TODO: cite). However, our implementation was developed completely from scratch, and many details differ from the approach outlined in the paper.

\subsection{Runtime support}

This consists of a function \lstinline{ocaml_liballocs_close(fun_impl, n_args, env)}
which dynamically creates a 3-instruction stub in an executable buffer,
returning what looks like a closed function pointer f. Note that this won't work on anything but 64-bit Linux.

Note that this code must be written to a memory page which has both write and execute permissions. (This has security implications which mean that additional precautionary steps must be taken if this technique is to be used in production code.)

This area of memory is bump allocated. Note that a garbage collector would need to know about this.

\subsubsection{Closing functions that take $\le 5$ arguments}

This is the stub (when \lstinline{n_args} $\le 5$):

\begin{lstlisting}
mov REG_ENV, <env>
mov r10, <fun_impl>
jmp r10
\end{lstlisting}

This works by writing the two 8-byte addresses directly into the machine code, and using immediate \lstinline{mov} instructions to load them into the required registers. Then the function is tail-called into.

This is what the stack transformation looks like: % TODO

\begin{tabular}{ c | c }
  \lstinline!n_args! & \lstinline!REG_ENV! \\
  \hline
  0 & \lstinline!rdi! \\
  1 & \lstinline!rsi! \\
  2 & \lstinline!rdx! \\
  3 & \lstinline!rcx! \\
  4 & \lstinline!r8! \\
  5 & \lstinline!r9! \\
  $> 5$ & passed on stack instead (see below) \\
\end{tabular}

\subsubsection{Closing functions that take $> 5$ arguments}

When \lstinline{n_args} $> 5$, env needs to get passed in on the stack instead.
This is a little awkward because:
\begin{enumerate}
    \item because we modify the stack, our stub can no longer just tail-call into \lstinline{fun_impl} -- it needs to clean up after itself;
  \item we need to somehow tuck \lstinline{env} in under the return address stack slot, which would require a large amount of stack twiddling.
\end{enumerate}

Luckily, I came up with a neat trick which addresses both issues and remains performant. We can get away with just pushing \lstinline{env} on top (forming the (\lstinline{n_args}${}+2$)th argument), and pretending the return address is actually an argument (\lstinline{n_args}${}+1$).

\begin{lstlisting}
mov r11, <env>
push r11
mov r10, <fun_impl>
call r10
pop rcx
ret
\end{lstlisting}

This is what the stack transformation looks like: % TODO

This works because our compiler has control over the function signature of
\lstinline{f}
-- so in this case it'll just insert an additional \lstinline{void *ignored} argument before \lstinline{env}.

Note also the deliberate choice of \lstinline{pop rcx} to remove the \lstinline{env} address from the stack (instead of, for instance \lstinline{pop r11} or \lstinline{add rsp, 8}). This is a size optimisation -- the chosen instruction encodes in just one byte.

\subsection{Compiler support}

As OCaml immediate value representations are immutable, we can simply copy the values of each free variable into the environment at the time of closure creation.

There is no explicit annotation in the OCaml lambda IR to indicate that a closure must be created -- the compiler has to perform free-variable analysis to determine this itself. We handle two scenarios where closures must be created:

\begin{itemize}
    \item \textbf{Function let-binding with non-empty free variable set}:
        \ldots
    \item \textbf{Partial application}:
        \ldots
\end{itemize}

\subsubsection{Recursive and mutually recursive closures}

Mutually recursive closures share an environment. Hence calls between two mutually recursive closures must pass the same environment pointer to each invocation.

Self-recursive closures are a special case of this.


\section{NaN boxing}

In order to support polymorphic comparisons, we need to use a technique to be able to distinguish pointers from immediate ints and doubles.

We use a technique called NaN boxing. Inspired by the WebKit JSCore

\begin{tabular}{c c c}
    63..52 & 51..0 & purpose \\
    \lstinline!fff! & \lstinline!0000000000000! & Negative infinity \\
    \lstinline!fff! & \lstinline!4000000000000! & Negative signalling NaN (canonical) \\
    \lstinline!fff! & \lstinline!8000000000000! & Negative quiet NaN (canonical) \\
    \lstinline!fff! & \lstinline!b000000000000! & Integers (50-bit space) \\
    \lstinline!fff! & \lstinline!effffffffffff! & Integers (50-bit space) \\
    \lstinline!fff! & \lstinline!f000000000000! & Pointers (48-bit space) \\
    \lstinline!fff! & \lstinline!fffffffffffff! & Pointers (50-bit space)
\end{tabular}


\chapter{Evaluation}

%TODO

\chapter{Conclusion}

%TODO


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the bibliography
\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{refs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the appendices
\appendix

\chapter{Latex source}

\section{diss.tex}
{\scriptsize\verbatiminput{diss.tex}}

\section{proposal.tex}
{\scriptsize\verbatiminput{proposal.tex}}

\chapter{Makefile}

\section{makefile}\label{makefile}
%{\scriptsize\verbatiminput{makefile.txt}}

%\section{refs.bib}
%{\scriptsize\verbatiminput{refs.bib}}


\chapter{Project Proposal}

%\input{proposal}

\end{document}
