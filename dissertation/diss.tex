% Template for a Computer Science Tripos Part II project dissertation
\documentclass[12pt,a4paper,twoside,openright]{report}
\usepackage[pdfborder={0 0 0}]{hyperref}    % turns references into hyperlinks
\usepackage[margin=25mm]{geometry}  % adjusts page layout
\usepackage{graphicx}  % allows inclusion of PDF, PNG and JPG images
\usepackage{verbatim}
\usepackage{docmute}   % only needed to allow inclusion of proposal.tex
\usepackage{amsmath}


\usepackage{listings}       % Source code listings
\usepackage{courier}        % courier font
\lstset{
  basicstyle=\ttfamily
, commentstyle=\color{Green}
, keywordstyle=\bfseries\color{RoyalBlue}
, showspaces=false
, showstringspaces=false
, breaklines=true
, breakatwhitespace=true
, framextopmargin=50pt
, columns=fullflexible,keepspaces
, escapeinside={(*}{*)}
%, frame=bottomline
      }



\raggedbottom                           % try to avoid widows and orphans
\sloppy
\clubpenalty1000%
\widowpenalty1000%

\renewcommand{\baselinestretch}{1.1}    % adjust line spacing to make
                                        % more readable

\begin{document}

\bibliographystyle{plain}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title


\pagestyle{empty}

\rightline{\LARGE \textbf{Cheng Sun}}

\vspace*{60mm}
\begin{center}
\Huge
\textbf{An observable OCaml via C and \texttt{liballocs}} \\[5mm]
Computer Science Tripos -- Part II \\[5mm]
Churchill College \\[5mm]
\today  % today's date
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Proforma, table of contents and list of figures

\pagestyle{plain}

\chapter*{Proforma}

{\large
\begin{tabular}{ll}
Name:               & \bf Cheng Sun                       \\
College:            & \bf Churchill College                     \\
Project Title:      & \bf An observable OCaml via C and \texttt{liballocs} \\
Examination:        & \bf Computer Science Tripos -- Part II, July 2017  \\
Word Count:         & \bf 1587\footnotemark[1] \\
Project Originator: & Stephen Kell                    \\
Supervisor:         & Stephen Kell                    \\
\end{tabular}
}
\footnotetext[1]{This word count was computed
by \texttt{detex diss.tex | tr -cd '0-9A-Za-z $\tt\backslash$n' | wc -w}
}
\stepcounter{footnote}


\section*{Original Aims of the Project}

%TODO
%To write a demonstration dissertation\footnote{A normal footnote without the
%complication of being in a table.} using \LaTeX\ to save
%student's time when writing their own dissertations. The dissertation
%should illustrate how to use the more common \LaTeX\ constructs. It
%should include pictures and diagrams to show how these can be
%incorporated into the dissertation.  It should contain the entire
%\LaTeX\ source of the dissertation and the makefile.  It should
%explain how to construct an MSDOS disk of the dissertation in
%Postscript format that can be used by the book shop for printing, and,
%finally, it should have the prescribed layout and format of a diploma
%dissertation.


\section*{Work Completed}

%TODO
%All that has been completed appears in this dissertation.

\section*{Special Difficulties}

%TODO
%Learning how to incorporate encapulated postscript into a \LaTeX\
%document on both Ubuntu Linux and OS X.
 
\newpage
\section*{Declaration}

I, Cheng Sun of Churchill College, being a candidate for Part II of the Computer
Science Tripos, hereby declare
that this dissertation and the work described in it are my own work,
unaided except as may be specified below, and that the dissertation
does not contain material that has already been used to any substantial
extent for a comparable purpose.

\bigskip
\leftline{Signed [signature]}

\medskip
\leftline{Date [date]}

\tableofcontents

\listoffigures

\newpage
\section*{Acknowledgements}

%TODO
%This document owes much to an earlier version written by Simon Moore
%\cite{Moore95}.  His help, encouragement and advice was greatly 
%appreciated.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% now for the chapters

\pagestyle{headings}

\chapter{Introduction}

%TODO


\chapter{Preparation}

%TODO


\chapter{Implementation}

\section{Summary and structure of code}

\begin{enumerate}
  \item the driver
  \item the compilation module
    \begin{enumerate}
      \item AST
      \item translate
      \item fixup
      \item emitcode
    \end{enumerate}
  \item the runtime
    \begin{enumerate}
      \item OCaml standard library
      \item C runtime library
    \end{enumerate}
\end{enumerate}

\subsection{\texttt{module C}: the extended C abstract syntax tree datatype}

I have defined a datatype representing a C-like syntax tree. Not all C features are modelled -- only the constructs that my compiler needs to produce. Furthermore, the datatype is slightly more expressive than standard ANSI C, as detailed later in section (TODO).

The following datatypes are defined:

\begin{itemize}
  \item
    \lstinline!C.ctype! represents a C type.
    
    For instance, a function pointer of type \lstinline!void (*)(double *)! is represented as \lstinline!C_FunPointer (C_Void, C_Pointer C_Double)!.
  \item
    \lstinline!C.expression! represents an expression -- program fragments that evaluate to a value (possibly of type \lstinline!void!). This encompasses for instance literals, function calls, and binary operators.

    For instance, the expression \lstinline!foo + 2! is represented as \lstinline!C_BinaryOp (C_Variable foo, "+", C_IntLiteral (Int64.of_int 2))! (where \lstinline!foo : Ident.t! is a value representing the \lstinline!foo! variable).

	\item
		\lstinline!C.statement! represents a statement -- language constructs such as \lstinline!if!, \lstinline!while!, \lstinline!return! etc. Note that statements typically contain one or more expressions, whereas expressions cannot* (TODO) contain statements.

	\item
		\lstinline!C.toplevel! represents a function or global variable declaration/definition at the toplevel.
\end{itemize}

Refer to (appendix ? TODO) for the complete datatype definition.

\subsection{\texttt{module Translate}: compilation from lambda IR to C AST}

\subsubsection{Inline statements}

The fact that C language makes a distinction between ``statements'' and ``expressions'' makes it less expressive than OCaml, as all core language features in OCaml are expressions. In particular, consider the translation of the following OCaml code:

\begin{lstlisting}
let x = if foo then (if bar then 1 else 2) else 3
\end{lstlisting}

Clearly a direct translation of this wouldn't work, as in C \lstinline!if! statements cannot be used as expressions. (TODO footnote about ternary operator)

The way that we handle this is by extending our \lstinline!C.expression! so
that statements can become expressions.  We add a new constructor
\lstinline!C_InlineRevStatements of C.statement! to the
\lstinline!C.expression! type, which allows us to use any C statement as if it
were an expression.

By doing this, our example from above can be translated directly, simply by wrapping the \lstinline!C_If! statements in ``inline statements''.

\subsubsection{Inline function definitions (lambdas)}

\begin{lstlisting}
let x = (fun x -> x + 1) 2
\end{lstlisting}

\subsection{\texttt{module Fixup}: translation from extended-C AST to valid C AST}

Similar to \lstinline!Translate!, the implementation of \lstinline!Fixup! is done via a recursive tree-walk. Three mutually recursive functions each visit different types of nodes:

\begin{lstlisting}
var fixup_let_defs :
  Fixup.t -> C.statement list -> C.let_definition list ->
  C.statement list

var fixup_expression :
  Fixup.t -> C.statement list -> C.expression ->
  C.statement list * C.expression

var fixup_rev_statements :
  Fixup.t -> C.statement list -> C.statement list ->
  C.statement list
\end{lstlisting}

Each fixup function is invoked in the form \lstinline!fixup_foo t accum foo!

\subsection{\texttt{module Emitcode}: outputting C AST to a file}

\subsection{Driver modification}

Support was added to the \lstinline!ocamlc! driver binary to generate and output C code. A new flag \lstinline!-target-liballocs! was added. After the simplified lambda IR is generated as usual, the presence of this flag will trigger the additional phase of compiling and outputting the C code in addition to running the rest of the compiler pipeline.

\section{Standard library: \texttt{module Pervasives}}

\subsection{C runtime}

The Pervasives module exposes (and internally uses) a large number of external predefined runtime functions (such as \lstinline!caml_sys_exit!), normally provided by the OCaml C runtime library. However, this library makes many assumptions about OCaml's tagged value representation, and is deeply integrated with the garbage collector. Hence new implementations of these functions had to be made.

I only implemented the functions that were necessary for the subset of stdlib functionality that was required to run my tests and benchmarks.

See appendix TODO for details.

\subsection{Printing to \texttt{stdout} and \texttt{stderr}}

Two sets of C runtime functions had to be implemented in order to support Pervasives functions such as \lstinline!print_int!. Int-to-string formatting and string printing are all delegated to the runtime library.

\section{Inter-module linking}

Each \lstinline!.ml! file in OCaml implicitly defines a toplevel module. The approach I have taken is to represent each such module as an array of values, the order of which is defined by the OCaml compiler.

At the lambda IR all inter-modular value/function accesses have already been lowered to \lstinline!getfield! operations on module objects. For instance, a call to \lstinline!Foo.bar! will already be represented by something like \lstinline!getfield Foo 1!. The ordering of values in modules is determined by the OCaml compiler based on the module's interface (\lstinline!.mli! file if it exists). This scheme implicitly handles data abstraction for us.

A module \lstinline!foo.ml! generates a file \lstinline!foo.c! declaring global variable \lstinline!ocaml_value_t *Foo! (the ``module object'') and global function \lstinline!void Foo__init()! (the ``module constructor''). This module constructor function is idempotent, and after a call to it the module object is guaranteed to contain valid values. Furthermore all global side effects in \lstinline!foo.ml! are also performed when the module is initialised for the first time.

Note that \lstinline!Foo! may well depend on other modules, such as \lstinline!Pervasives!. In \lstinline!foo.c! any such dependencies are represented as predeclarations of the module objects and constructors, and calls to constructors at the start of \lstinline!Foo__init!. The skeleton of such a module is shown in the listing below:

\begin{lstlisting}
#include "liballocs_runtime.h"

void Pervasives__init();
extern ocaml_value_t *Pervasives;

ocaml_value_t *Foo;

void Foo__init() {
    if (Foo) {
        return;
    } else {
        Pervasives__init();

        // allocate and construct module object Foo
    }
}
\end{lstlisting}

\section{Closures}

C allows function references to be stored in variables, in the form of
``function pointers'' containing the address of the start of the function's
machine code. Calls are performed on function pointers by an indirect jump to
the address (using the \lstinline!call! instruction).

The C language has no notion of closures, which OCaml requires to provide
support for lexical scoping of variables in first-class functions. Closures are
conceptually a tuple of the function pointer and an environment, which stores
the free variables of the closure. Hence, we need to add support for generating
closures manually.

One way to represent closures is as ``fat pointers'', where each closure is
stored as a tuple of two pointers. Note however that in OCaml a closure may be
used whenever a function is expected, so each indirect function call would now
have to check whether the function reference is fat or not -- a significant
runtime cost.

A unified way to call closures and function pointers is desired. In
particular, we'd like the act of closing a C function \lstinline!f_impl! with
an environment \lstinline!env! to produce a fresh function pointer
\lstinline!f_closure!, such that calling
\lstinline!f_closure(1, 2, 3)!
with the standard C calling convention is equivalent to a call to
\lstinline!f_impl(1, 2, 3, env)!.

The technique that we use involves the creation of machine code stubs at
runtime. This was pioneered by Breuel (TODO: cite). However, our implementation
was developed completely from scratch, and many details differ from the
approach outlined in the paper.

\subsection{Runtime support}

An internal C function \lstinline{ocaml_liballocs_close(f_impl, n_args, env)}
was written, which performs the closing operation as previously described.
\lstinline!f_impl! is the C implementation of the closure -- a function which
takes \lstinline!n_args! arguments along with an extra argument containing the environment.

When \lstinline!ocaml_liballocs_close! is
invoked, a small executable stub is written into an executable
buffer, with the two pointers \lstinline!f_impl! and \lstinline!env! baked in.
Then the address of the start of this stub is returned. The stub is described
in detail below.

Conceptually, the operation can be described as JIT-compiling the following
snippet of pseudo-C code at runtime: (NB: caveat for $> 5$ arguments TODO)

\begin{lstlisting}
ocaml_value_t f_closure(ocaml_value_t arg1,
                        ...,
                        ocaml_value_t argn)
{
    return f_impl(arg1, ..., argn, env);
}
\end{lstlisting}

Note that as implemented, this won't work on anything but 64-bit Linux.

Note that this code must be written to a memory page which has both write and
execute permissions. (This has security implications which mean that additional
precautionary steps must be taken if this technique is to be used in production
code.)

This area of memory is bump allocated. Note that a garbage collector would need
to be taught about this.

\subsubsection{Closing functions that take $\le 5$ arguments}

An Application Binary Interface (ABI) specifies a standardised calling
convention which programs and libraries adhere to. This includes the
specification of the location in registers or memory where function arguments
are passed.

On POSIX compliant systems (this does not include Windows!) C uses AMD's x86-64
ABI. The first six arguments are passed in registers in a particular order,
shown in the table below. Hence, when closing a function \lstinline!f! which
originally took five or fewer arguments, there is space to pass \lstinline!env!
in another register.

Conveniently, all six argument registers are also caller-preserved whether they
are used to pass arguments or not. This means that our stub is allowed to
overwrite (or ``clobber'') any of them without having to clean up afterwards.
There are also several other caller-preserved registers, notably
\lstinline!r10!, which we will also make use of.

The following is the table of the register used for each argument in the x86-64
ABI.

\begin{tabular}{ c | c }
  $n$th argument & register \\
  \hline
  1 & \lstinline!rdi! \\
  2 & \lstinline!rsi! \\
  3 & \lstinline!rdx! \\
  4 & \lstinline!rcx! \\
  5 & \lstinline!r8! \\
  6 & \lstinline!r9!
\end{tabular}

We shall place \lstinline!env! into the $(\text{\lstinline|n\_args|}+1)$-th argument. Call the
corresponding register \lstinline!REG_ENV!.

This is the assembly listing for the machine code generated:

\begin{lstlisting}
mov REG_ENV, <env>
mov r10, <f_impl>
jmp r10
\end{lstlisting}

This works by using two 8-byte immediate \lstinline!mov! instructions, which
each load a fixed constant from the program code, which happen to correspond to
our two pointers \lstinline!env! and \lstinline!f_impl!.
Then \lstinline!f_impl! is tail-called into.

\subsubsection{Closing functions that take $> 5$ arguments}

When \lstinline!n_args! $> 5$, \lstinline!env! needs to get passed in on the
stack instead.

\begin{tabular}{c}
  \lstinline!arg_7!
  \\ \hline
  \vdots
  \\ \hline
  \lstinline!arg_n!
  \\ \hline\hline
  return address to caller
\end{tabular}

However, implementing the direct solution is a little awkward because:
\begin{enumerate}
  \item when we modify the stack, our stub can no longer just tail-call
    into \lstinline!f_impl! -- before returning to the caller we need to undo
    our stack transformation;
  \item we need to tuck \lstinline!env! in under the return address
    stack slot, which would require a large number of stack-twiddling
    instructions.
\end{enumerate}

Luckily, I came up with a neat trick which addresses both issues and remains
performant. It turns out that we can get away with just pushing \lstinline!env! on top of the stack as follows, before \lstinline!call!ing into \lstinline!f_impl!. The state of the stack on entry to \lstinline!f_impl! is:

\begin{tabular}{c}
  \lstinline!arg_7!
  \\ \hline
  \vdots
  \\ \hline
  \lstinline!arg_n!
  \\ \hline
  return address to caller
  \\ \hline
  \lstinline!env!
  \\ \hline\hline
  return address to stub
\end{tabular}

By treating the return address to caller as an extra (unused) argument to
\lstinline!f_impl!, it can now access \lstinline!env! through its
(\lstinline{n_args}${}+2$)th argument.

This trick works because our compiler has control over the function signature
of \lstinline{f} -- in this case it'll just insert an additional
\lstinline{void *ignored} argument before \lstinline{env}.

Now the machine code stub looks like this:

\begin{lstlisting}
mov r11, <env>
push r11
mov r10, <f_impl>
call r10
pop rcx
ret
\end{lstlisting}

Note the deliberate choice of \lstinline{pop rcx} to remove the
\lstinline{env} address from the stack (instead of, for instance
\lstinline{pop r11} or \lstinline{add rsp, 8}). This is a size optimisation --
the chosen instruction encodes in just one byte.

\subsection{Compiler support}

As OCaml immediate value representations are immutable, we can simply copy the
values of each free variable into the environment at the time of closure
creation.

There is no explicit annotation in the OCaml lambda IR to indicate that a
closure must be created -- the compiler has to perform free-variable analysis
to determine this itself. We handle three separate scenarios where closures
must be created:

\begin{itemize}
    \item \textbf{Function let-binding with non-empty free variable set}:
        \ldots
    \item \textbf{Anonymous lambda}:
        \ldots
    \item \textbf{Partial application}:
        \ldots
\end{itemize}

\subsubsection{Recursive and mutually recursive closures}

Mutually recursive closures share an environment. Hence calls between two mutually recursive closures must pass the same environment pointer to each invocation.

Self-recursive closures are a special case of this.


\section{NaN boxing}

In order to support polymorphic comparisons, we need to use a technique to be able to distinguish pointers from immediate ints and doubles.

We use a technique called NaN boxing. Inspired by the WebKit JSCore

\begin{tabular}{c c | c c | c}
    63..52 & 51..0 & 63..52 & 51..0 & purpose \\
    \lstinline!fff! & \lstinline!0000000000000! & \lstinline!fff! & \lstinline!1000000000000! & Negative infinity \\
    \lstinline!fff! & \lstinline!4000000000000! & \lstinline!fff! & \lstinline!5000000000000! & Negative signalling NaN (canonical) \\
    \lstinline!fff! & \lstinline!8000000000000! & \lstinline!fff! & \lstinline!9000000000000! & Negative quiet NaN (canonical) \\
    \lstinline!fff! & \lstinline!b000000000000! & \lstinline!fff! & \lstinline!c000000000000! & Integers (50-bit space) \\
    \lstinline!fff! & \lstinline!effffffffffff! & \lstinline!fff! & \lstinline!fffffffffffff! & Integers (50-bit space) \\
    \lstinline!fff! & \lstinline!f000000000000! & \lstinline!000! & \lstinline!0000000000000! & Pointers (48-bit space) \\
    \lstinline!fff! & \lstinline!fffffffffffff! & \lstinline!000! & \lstinline!0ffffffffffff! & Pointers (48-bit space)
\end{tabular}



\section{Exceptions}

OCaml has support for exceptions: a \lstinline!raise Foo! causes the
exception \lstinline!Foo! to propagate up through stack frames until a
\lstinline!try _ with Foo -> _! block is found.

Interestingly, exceptions is one of the cases where the lambda IR is more
complex than the OCaml language. Lambda distinguishes between static (local)
exceptions, and non-static ones.

Once again, because of the undocumented nature of the lambda IR, the semantics
of these instructions were divined through reverse engineering and code diving.

\subsection{Static exceptions}

Static exceptions are confined to a lexically local scope -- i.e. the raise and the corresponding try are in the same function. The lambda instructions for these are \lstinline!Lstaticraise! and \lstinline!Lstaticcatch!.

In this case, we can implement these using the C \lstinline!goto! feature, which allows control flow to jump non-linearly to another point in the same function.

The structure gets compiled into the following construct:

\begin{lstlisting}
if (1) {
    /* body */
    // goto label_staticcatch_1;
} else {
label_staticcatch_1:;
    /* handler */
}
\end{lstlisting}

\subsection{Non-static exceptions}

More generally an exception may unwind through several stack frames, and may be caught in different handlers depending on the dynamic runtime behaviour.

C has a mechanism to perform ``non-local'' jumps using the special library calls \lstinline!setjmp! and \lstinline!longjmp!. A call to \lstinline!setjmp! will save the CPU registers at the point the function was called (notably, including the instruction and stack pointers) into a \lstinline!struct jmpbuf! that the user provides. Calling \lstinline!longjmp! will then restore the state of the program, so that execution flow resumes as if the original \lstinline!setjmp! returned for a second time. \lstinline!setjmp! will return non-zero iff it is returning for the second time.

I use this mechanism to support exception handling. TODO

\begin{lstlisting}
  if (setjmp(jmp_buf) == 0) {
    // first time
    longjmp(jmp_buf);
  } else {
    // second time
  }
\end{lstlisting}

\lstinline!setjmp! allows control flow to ``unwind'' to the last installed exception handler. The value of the exception currently being handled is stored in a global variable known to the compiler, so that exception handlers can pattern match against it. The exception handler is uninstalled (``popped'' off the stack of exception handlers) when:
\begin{itemize}
  \item a try block finishes without raising; or
  \item a handler starts executing. This prevents exceptions raised inside the handler from incorrectly being recursively handled by itself.
\end{itemize}

The memory representation of an exception contains the stringified name of the exception, so that if it is propagated all the way up unhandled, the runtime can print the name of the exception before aborting.

\subsection{Runtime support}

\subsubsection{Toplevel handler}

If an exception propagates all the way to the top without being handled successfully, the runtime needs to print an error message and abort the program. This is done by installing a root handler in \lstinline!main! before calling into OCaml code.

Assuming that the module being compiled is called \lstinline!Test!, the following is the C \lstinline!main! function:

\begin{lstlisting}
void Test__init();

int main() {
    // set up root exception handler
    OCAML_LIBALLOCS_EXN_PUSH();
    if (0 == OCAML_LIBALLOCS_EXN_SETJMP()) {
        Test__init();
        return 0;
    } else { // catch
        OCAML_LIBALLOCS_EXN_POP();
        fprintf(stderr, "Uncaught OCaml exception: %s\n",
                (const char *)
                  GET_P(GET_P(ocaml_liballocs_get_exn())[0]));
        return 1;
    }
}
\end{lstlisting}

\subsubsection{Builtin exceptions}

A number of important exceptions are embedded fairly deep in the OCaml
language, surprisingly at a lower level than even the \lstinline!Pervasives!
module. OCaml raises some of these exceptions specially for various reasons --
for example the \lstinline!Division_by_zero! OCaml exception is raised when the
corresponding FPU exception occurs.

As these exceptions are not defined in the usual way, in OCaml code, we must
manually declare and instantiate these exceptions in our own C runtime library.
The list of predefined exceptions can be found in \lstinline!typing/predef.ml!.
The C preprocessor quote trick allows us to succinctly define the list of
builtin exceptions statically:

\begin{lstlisting}
#define _QUOTE(x) #x
#define QUOTE(x) _QUOTE(x)
#define DEFINE_BUILTIN_EXCEPTION(name) \
    ocaml_value_t __##name[2] = { \
        NEW_P((generic_datap_t) QUOTE(name)), \
        NEW_I(0) \
    }; \
    ocaml_value_t *name = __##name;

DEFINE_BUILTIN_EXCEPTION(Match_failure)
DEFINE_BUILTIN_EXCEPTION(Assert_failure)
...
\end{lstlisting}

\chapter{Evaluation}

%TODO

\chapter{Conclusion}

%TODO


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the bibliography
\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{refs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the appendices
\appendix

\chapter{Latex source}

\section{diss.tex}
{\scriptsize\verbatiminput{diss.tex}}

\section{proposal.tex}
{\scriptsize\verbatiminput{proposal.tex}}

\chapter{Makefile}

\section{makefile}\label{makefile}
%{\scriptsize\verbatiminput{makefile.txt}}

%\section{refs.bib}
%{\scriptsize\verbatiminput{refs.bib}}


\chapter{Project Proposal}

%\input{proposal}

\end{document}
