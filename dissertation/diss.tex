% Template for a Computer Science Tripos Part II project dissertation
\documentclass[12pt,a4paper,twoside,openright]{report}
\usepackage[pdfborder={0 0 0}]{hyperref}    % turns references into hyperlinks
\usepackage[margin=25mm]{geometry}  % adjusts page layout
\usepackage{graphicx}  % allows inclusion of PDF, PNG and JPG images
\usepackage{verbatim}
\usepackage{docmute}   % only needed to allow inclusion of proposal.tex


\usepackage{listings}       % Source code listings
\usepackage{courier}        % courier font
\lstset{
  basicstyle=\ttfamily
, commentstyle=\color{Green}
, keywordstyle=\bfseries\color{RoyalBlue}
, showspaces=false
, showstringspaces=false
, breaklines=true
, breakatwhitespace=true
, framextopmargin=50pt
, columns=fullflexible,keepspaces
, escapeinside={(*}{*)}
%, frame=bottomline
      }



\raggedbottom                           % try to avoid widows and orphans
\sloppy
\clubpenalty1000%
\widowpenalty1000%

\renewcommand{\baselinestretch}{1.1}    % adjust line spacing to make
                                        % more readable

\begin{document}

\bibliographystyle{plain}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title


\pagestyle{empty}

\rightline{\LARGE \textbf{Cheng Sun}}

\vspace*{60mm}
\begin{center}
\Huge
\textbf{An observable OCaml via C and \lstinline!liballocs!} \\[5mm]
Computer Science Tripos -- Part II \\[5mm]
Churchill College \\[5mm]
\today  % today's date
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Proforma, table of contents and list of figures

\pagestyle{plain}

\chapter*{Proforma}

{\large
\begin{tabular}{ll}
Name:               & \bf Cheng Sun                       \\
College:            & \bf Churchill College                     \\
Project Title:      & \bf An observable OCaml via C and \lstinline!liballocs! \\
Examination:        & \bf Computer Science Tripos -- Part II, July 2017  \\
Word Count:         & \bf 1587\footnotemark[1] \\
Project Originator: & Stephen Kell                    \\
Supervisor:         & Stephen Kell                    \\
\end{tabular}
}
\footnotetext[1]{This word count was computed
by \texttt{detex diss.tex | tr -cd '0-9A-Za-z $\tt\backslash$n' | wc -w}
}
\stepcounter{footnote}


\section*{Original Aims of the Project}

%TODO
%To write a demonstration dissertation\footnote{A normal footnote without the
%complication of being in a table.} using \LaTeX\ to save
%student's time when writing their own dissertations. The dissertation
%should illustrate how to use the more common \LaTeX\ constructs. It
%should include pictures and diagrams to show how these can be
%incorporated into the dissertation.  It should contain the entire
%\LaTeX\ source of the dissertation and the makefile.  It should
%explain how to construct an MSDOS disk of the dissertation in
%Postscript format that can be used by the book shop for printing, and,
%finally, it should have the prescribed layout and format of a diploma
%dissertation.


\section*{Work Completed}

%TODO
%All that has been completed appears in this dissertation.

\section*{Special Difficulties}

%TODO
%Learning how to incorporate encapulated postscript into a \LaTeX\
%document on both Ubuntu Linux and OS X.
 
\newpage
\section*{Declaration}

I, Cheng Sun of Churchill College, being a candidate for Part II of the Computer
Science Tripos, hereby declare
that this dissertation and the work described in it are my own work,
unaided except as may be specified below, and that the dissertation
does not contain material that has already been used to any substantial
extent for a comparable purpose.

\bigskip
\leftline{Signed [signature]}

\medskip
\leftline{Date [date]}

\tableofcontents

\listoffigures

\newpage
\section*{Acknowledgements}

%TODO
%This document owes much to an earlier version written by Simon Moore
%\cite{Moore95}.  His help, encouragement and advice was greatly 
%appreciated.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% now for the chapters

\pagestyle{headings}

\chapter{Introduction}

%TODO


\chapter{Preparation}

%TODO


\chapter{Implementation}

\section{Summary and structure of code}

\begin{enumerate}
  \item the driver
  \item the compilation module
    \begin{enumerate}
      \item AST
      \item translate
      \item fixup
      \item emitcode
    \end{enumerate}
  \item the runtime
    \begin{enumerate}
      \item OCaml standard library
      \item C runtime library
    \end{enumerate}
\end{enumerate}

\subsection{\lstinline!module C!: the extended C abstract syntax tree datatype}

I have defined a datatype representing a C-like syntax tree. Not all C features are modelled -- only the constructs that my compiler needs to produce. Furthermore, the datatype is slightly more expressive than standard ANSI C, as detailed later in section (TODO).

The following datatypes are defined:

\begin{itemize}
  \item
    \lstinline!C.ctype! represents a C type.
    
    For instance, a function pointer of type \lstinline!void (*)(double *)! is represented as \lstinline!C_FunPointer (C_Void, C_Pointer C_Double)!.
  \item
    \lstinline!C.expression! represents an expression -- program fragments that evaluate to a value (possibly of type \lstinline!void!). This encompasses for instance literals, function calls, and binary operators.

    For instance, the expression \lstinline!foo + 2! is represented as \lstinline!C_BinaryOp (C_Variable foo, "+", C_IntLiteral (Int64.of_int 2))! (where \lstinline!foo : Ident.t! is a value representing the \lstinline!foo! variable).

	\item
		\lstinline!C.statement! represents a statement -- language constructs such as \lstinline!if!, \lstinline!while!, \lstinline!return! etc. Note that statements typically contain one or more expressions, whereas expressions cannot* (TODO) contain statements.

	\item
		\lstinline!C.toplevel! represents a function or global variable declaration/definition at the toplevel.
\end{itemize}

Refer to (appendix ? TODO) for the complete datatype definition.

\subsection{\lstinline!module Translate!: compilation from lambda IR to C AST}

\subsubsection{Inline statements}

The fact that C language makes a distinction between ``statements'' and ``expressions'' makes it less expressive than OCaml, as all core language features in OCaml are expressions. In particular, consider the translation of the following OCaml code:

\begin{lstlisting}
let x = if foo then (if bar then 1 else 2) else 3
\end{lstlisting}

\subsubsection{Inline function definitions (lambdas)}

\begin{lstlisting}
let x = (fun x -> x + 1) 2
\end{lstlisting}

\subsection{\lstinline!module Fixup!: translation from extended-C AST to valid C AST}

\subsection{\lstinline!module Emitcode!: outputting C AST to a file}

\subsection{Driver modification}

Support was added to the \lstinline!ocamlc! driver binary to generate and output C code. A new flag \lstinline!-target-liballocs! was added. After the simplified lambda IR is generated as usual, the presence of this flag will trigger the additional phase of compiling and outputting the C code in addition to running the rest of the compiler pipeline.

\section{Standard library: \lstinline!module Pervasives!}

\subsection{C runtime}

The Pervasives module exposes (and internally uses) a large number of external predefined runtime functions (such as \lstinline!caml_sys_exit!), normally provided by the OCaml C runtime library. However, this library makes many assumptions about OCaml's tagged value representation, and is deeply integrated with the garbage collector. Hence new implementations of these functions had to be made.

I only implemented the functions that were necessary for the subset of stdlib functionality that was required to run my tests and benchmarks.

See appendix TODO for details.

\subsection{Printing to \lstinline!stdout! and \lstinline!stderr!}

Two sets of C runtime functions had to be implemented in order to support Pervasives functions such as \lstinline!print_int!. Int-to-string formatting and string printing are all delegated to the runtime library.

\section{Inter-module linking}

Each \lstinline!.ml! file in OCaml implicitly defines a toplevel module. The approach I have taken is to represent each such module as an array of values, the order of which is defined by the OCaml compiler.

At the lambda IR all inter-modular value/function accesses have already been lowered to \lstinline!getfield! operations on module objects. For instance, a call to \lstinline!Foo.bar! will already be represented by something like \lstinline!getfield Foo 1!. The ordering of values in modules is determined by the OCaml compiler based on the module's interface (\lstinline!.mli! file if it exists). This scheme implicitly handles data abstraction for us.

A module \lstinline!foo.ml! generates a file \lstinline!foo.c! declaring global variable \lstinline!ocaml_value_t *Foo! (the ``module object'') and global function \lstinline!void Foo__init()! (the ``module constructor''). This module constructor function is idempotent, and after a call to it the module object is guaranteed to contain valid values. Furthermore all global side effects in \lstinline!foo.ml! are also performed when the module is initialised for the first time.

Note that \lstinline!Foo! may well depend on other modules, such as \lstinline!Pervasives!. In \lstinline!foo.c! any such dependencies are represented as predeclarations of the module objects and constructors, and calls to constructors at the start of \lstinline!Foo__init!. The skeleton of such a module is shown in the listing below:

\begin{lstlisting}
#include "liballocs_runtime.h"

void Pervasives__init();
extern ocaml_value_t *Pervasives;

ocaml_value_t *Foo;

void Foo__init() {
    if (Foo) {
        return;
    } else {
        Pervasives__init();

        // allocate and construct module object Foo
    }
}
\end{lstlisting}

\section{Closures}

C allows function pointers to be stored and passed around in variables. These variables point to the start of the function's machine code in memory. Function calls are performed on function pointers by simply jumping to their address (using the \lstinline{call} instruction).

The C language has no notion of closures, which OCaml requires to provide support for lexical scoping of variables in first-class functions. Closures are conceptually a tuple of the function pointer and the ``environment'' of the closure, which contains information about the free variables of the closure.

We would like our closure pointers to be behaviourally equivalent to a function pointer from the C caller's perspective, i.e. calling
\lstinline{closure(1, 2, 3)}
(with the standard C calling convention) transparently translates to a call to
\lstinline{closure_impl(1, 2, 3, env)}. This precludes techniques such as ``fat pointers'', where closures are stored as a tuple of two pointers. The disadvantage of such techniques includes the fact that each indirect function call must first check whether the variable is fat or not -- a significant runtime penalty.

The technique that we use involves the creation of machine code stubs at runtime was pioneered by Breuel (TODO: cite). However, our implementation was developed completely from scratch, and many details differ from the approach outlined in the paper.

\subsection{Runtime support}

This consists of a function \lstinline{ocaml_liballocs_close(fun_impl, n_args, env)}
which dynamically creates a 3-instruction stub in an executable buffer,
returning what looks like a closed function pointer f. Note that this won't work on anything but 64-bit Linux.

Note that this code must be written to a memory page which has both write and execute permissions. (This has security implications which mean that additional precautionary steps must be taken if this technique is to be used in production code.)

This area of memory is bump allocated. Note that a garbage collector would need to know about this.

\subsubsection{Closing functions that take $\le 5$ arguments}

This is the stub (when \lstinline{n_args} $\le 5$):

\begin{lstlisting}
mov REG_ENV, <env>
mov r10, <fun_impl>
jmp r10
\end{lstlisting}

This works by writing the two 8-byte addresses directly into the machine code, and using immediate \lstinline{mov} instructions to load them into the required registers. Then the function is tail-called into.

This is what the stack transformation looks like: % TODO

\begin{tabular}{ c | c }
  \lstinline!n_args! & \lstinline!REG_ENV! \\
  \hline
  0 & \lstinline!rdi! \\
  1 & \lstinline!rsi! \\
  2 & \lstinline!rdx! \\
  3 & \lstinline!rcx! \\
  4 & \lstinline!r8! \\
  5 & \lstinline!r9! \\
  $> 5$ & passed on stack instead (see below) \\
\end{tabular}

\subsubsection{Closing functions that take $> 5$ arguments}

When \lstinline{n_args} $> 5$, env needs to get passed in on the stack instead.
This is a little awkward because:
\begin{enumerate}
    \item because we modify the stack, our stub can no longer just tail-call into \lstinline{fun_impl} -- it needs to clean up after itself;
  \item we need to somehow tuck \lstinline{env} in under the return address stack slot, which would require a large amount of stack twiddling.
\end{enumerate}

Luckily, I came up with a neat trick which addresses both issues and remains performant. We can get away with just pushing \lstinline{env} on top (forming the (\lstinline{n_args}${}+2$)th argument), and pretending the return address is actually an argument (\lstinline{n_args}${}+1$).

\begin{lstlisting}
mov r11, <env>
push r11
mov r10, <fun_impl>
call r10
pop rcx
ret
\end{lstlisting}

This is what the stack transformation looks like: % TODO

This works because our compiler has control over the function signature of
\lstinline{f}
-- so in this case it'll just insert an additional \lstinline{void *ignored} argument before \lstinline{env}.

Note also the deliberate choice of \lstinline{pop rcx} to remove the \lstinline{env} address from the stack (instead of, for instance \lstinline{pop r11} or \lstinline{add rsp, 8}). This is a size optimisation -- the chosen instruction encodes in just one byte.

\subsection{Compiler support}

As OCaml immediate value representations are immutable, we can simply copy the values of each free variable into the environment at the time of closure creation.

There is no explicit annotation in the OCaml lambda IR to indicate that a closure must be created -- the compiler has to perform free-variable analysis to determine this itself. We handle three separate scenarios where closures must be created:

\begin{itemize}
    \item \textbf{Function let-binding with non-empty free variable set}:
        \ldots
    \item \textbf{Anonymous lambda}:
        \ldots
    \item \textbf{Partial application}:
        \ldots
\end{itemize}

\subsubsection{Recursive and mutually recursive closures}

Mutually recursive closures share an environment. Hence calls between two mutually recursive closures must pass the same environment pointer to each invocation.

Self-recursive closures are a special case of this.


\section{NaN boxing}

In order to support polymorphic comparisons, we need to use a technique to be able to distinguish pointers from immediate ints and doubles.

We use a technique called NaN boxing. Inspired by the WebKit JSCore

\begin{tabular}{c c c}
    63..52 & 51..0 & purpose \\
    \lstinline!fff! & \lstinline!0000000000000! & Negative infinity \\
    \lstinline!fff! & \lstinline!4000000000000! & Negative signalling NaN (canonical) \\
    \lstinline!fff! & \lstinline!8000000000000! & Negative quiet NaN (canonical) \\
    \lstinline!fff! & \lstinline!b000000000000! & Integers (50-bit space) \\
    \lstinline!fff! & \lstinline!effffffffffff! & Integers (50-bit space) \\
    \lstinline!fff! & \lstinline!f000000000000! & Pointers (48-bit space) \\
    \lstinline!fff! & \lstinline!fffffffffffff! & Pointers (50-bit space)
\end{tabular}



\section{Exceptions}

OCaml has support for exceptions: -- a \lstinline!raise Foo! causes the exception \lstinline!Foo! to propagate up through stack frames until a \lstinline!try _ with Foo -> _! block is found.

Interestingly, exceptions is one of the cases where the lambda IR is more complex than the OCaml language. Lambda distinguishes between static (local) exceptions, and non-static ones.

Once again, because of the undocumented nature of the lambda IR, the semantics of these instructions were divined through reverse engineering and code diving.

\subsection{Static exceptions}

Static exceptions are confined to a lexically local scope -- i.e. the raise and the corresponding try are in the same function. The lambda instructions for these are \lstinline!Lstaticraise! and \lstinline!Lstaticcatch!.

In this case, we can implement these using the C \lstinline!goto! feature, which allows control flow to jump non-linearly to another point in the same function.

The structure gets compiled into the following construct:

\begin{lstlisting}
if (1) {
    /* body */
    // goto label_staticcatch_1;
} else {
label_staticcatch_1:;
    /* handler */
}
\end{lstlisting}

\subsection{Non-static exceptions}

More generally an exception may unwind through several stack frames, and may be caught in different handlers depending on the dynamic runtime behaviour.

C has a mechanism to perform ``non-local'' jumps using the special library calls \lstinline!setjmp! and \lstinline!longjmp!. A call to \lstinline!setjmp! will save the CPU registers at the point the function was called (notably, including the instruction and stack pointers) into a \lstinline!struct jmpbuf! that the user provides. Calling \lstinline!longjmp! will then restore the state of the program, so that execution flow resumes as if the original \lstinline!setjmp! returned for a second time. \lstinline!setjmp! will return non-zero iff it is returning for the second time.

I use this mechanism to support exception handling. TODO

\begin{lstlisting}
  if (setjmp(jmp_buf) == 0) {
    // first time
    longjmp(jmp_buf);
  } else {
    // second time
  }
\end{lstlisting}

The memory representation of an exception contains the stringified name of the exception, so that if it is propagated all the way up unhandled, the runtime can print the name of the exception before aborting.

\subsection{Runtime support}

A number of important exceptions are built in fairly deep in the OCaml language, surprisingly even outside of the \lstinline!Pervasives! module. OCaml raises some of these exceptions specially for various reasons -- for example the \lstinline!Division_by_zero! OCaml exception is raised when the corresponding FPU exception occurs.

As these are not defined in the OCaml part of the standard library, we have to manually instantiate these exceptions in our own C runtime library.

We use the C preprocessor quote trick to succinctly define the list of builtin exceptions statically.

\begin{lstinline}
#define _QUOTE(x) #x
#define QUOTE(x) _QUOTE(x)
#define DEFINE_BUILTIN_EXCEPTION(name) \
    ocaml_value_t __##name[2] = { \
        NEW_P((generic_datap_t) QUOTE(name)), \
        NEW_I(0) \
    }; \
    ocaml_value_t *name = __##name;

DEFINE_BUILTIN_EXCEPTION(Match_failure)
DEFINE_BUILTIN_EXCEPTION(Assert_failure)
\ldots
\end{lstinline}

\chapter{Evaluation}

%TODO

\chapter{Conclusion}

%TODO


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the bibliography
\addcontentsline{toc}{chapter}{Bibliography}
\bibliography{refs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% the appendices
\appendix

\chapter{Latex source}

\section{diss.tex}
{\scriptsize\verbatiminput{diss.tex}}

\section{proposal.tex}
{\scriptsize\verbatiminput{proposal.tex}}

\chapter{Makefile}

\section{makefile}\label{makefile}
%{\scriptsize\verbatiminput{makefile.txt}}

%\section{refs.bib}
%{\scriptsize\verbatiminput{refs.bib}}


\chapter{Project Proposal}

%\input{proposal}

\end{document}
